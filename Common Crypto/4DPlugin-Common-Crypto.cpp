/* --------------------------------------------------------------------------------
 #
 #  4DPlugin-Common-Crypto.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : Common Crypto
 #	author : miyako
 #	2019/08/16
 #
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-Common-Crypto.h"

#ifndef _CC_COMMON_HMAC_H_

void CC_EVP(const EVP_MD *evp, uint32_t mlen, const void *data, uint32_t len, unsigned char *md)
{

    unsigned int mdlen = mlen;
    EVP_MD_CTX *c = EVP_MD_CTX_new();
    EVP_MD_CTX_reset(c);
    EVP_DigestInit(c, evp);
    EVP_DigestUpdate(c, data, len);
    EVP_DigestFinal(c, md, &mdlen);
    EVP_MD_CTX_free(c);
}

void CC_EVP_XOF(const EVP_MD *evp, uint32_t mlen, const void *data,
                uint32_t len, uint32_t mdlen, unsigned char *md)
{

    EVP_MD_CTX *c = EVP_MD_CTX_new();
    EVP_MD_CTX_reset(c);
    EVP_DigestInit(c, evp);
    EVP_DigestUpdate(c, data, len);
    EVP_DigestFinalXOF(c, md, mdlen);
    EVP_MD_CTX_free(c);
}

void CC_MD5(const void *data, uint32_t len, unsigned char *md)
{
    CC_EVP(EVP_md5(), 16, data, len, md);
}

void CC_SHA1(const void *data, uint32_t len, unsigned char *md)
{
    CC_EVP(EVP_sha1(), 20, data, len, md);
}

void CC_SHA224(const void *data, uint32_t len, unsigned char *md)
{
    CC_EVP(EVP_sha224(), 28, data, len, md);
}

void CC_SHA256(const void *data, uint32_t len, unsigned char *md)
{
    CC_EVP(EVP_sha256(), 32, data, len, md);
}

void CC_SHA384(const void *data, uint32_t len, unsigned char *md)
{
    CC_EVP(EVP_sha384(), 48, data, len, md);
}

void CC_SHA512(const void *data, uint32_t len, unsigned char *md)
{
    CC_EVP(EVP_sha512(), 64, data, len, md);
}

void CC_SHA512_224(const void *data, uint32_t len, unsigned char *md)
{
    CC_EVP(EVP_sha512_224(), 28, data, len, md);
}

void CC_SHA512_256(const void *data, uint32_t len, unsigned char *md)
{
    CC_EVP(EVP_sha512_256(), 32, data, len, md);
}

// SHA3

void CC_SHA3_224(const void *data, uint32_t len, unsigned char *md)
{
    CC_EVP(EVP_sha3_224(), 28, data, len, md);
}

void CC_SHA3_256(const void *data, uint32_t len, unsigned char *md)
{
    CC_EVP(EVP_sha3_256(), 32, data, len, md);
}

void CC_SHA3_384(const void *data, uint32_t len, unsigned char *md)
{
    CC_EVP(EVP_sha3_384(), 48, data, len, md);
}

void CC_SHA3_512(const void *data, uint32_t len, unsigned char *md)
{
    CC_EVP(EVP_sha3_512(), 64, data, len, md);
}

void CC_SHAKE128(const void *data, uint32_t len, uint32_t mdlen, unsigned char *md)
{
    CC_EVP_XOF(EVP_shake128(), 32, data, len, mdlen, md);
}

void CC_SHAKE256(const void *data, uint32_t len, uint32_t mdlen, unsigned char *md)
{
    CC_EVP_XOF(EVP_shake256(), 64, data, len, mdlen, md);
}

// RIPEMD

void CC_RIPEMD160(const void *data, uint32_t len, unsigned char *md)
{
    CC_EVP(EVP_ripemd160(), 20, data, len, md);
}

#endif

#pragma mark -

void OnStartup()
{
    OPENSSL_init_crypto(OPENSSL_INIT_ADD_ALL_CIPHERS | OPENSSL_INIT_ADD_ALL_DIGESTS, NULL); // for PEM_From_P12
}

void PluginMain(PA_long32 selector, PA_PluginParameters params)
{

    try
    {

        switch (selector)
        {
        case kInitPlugin:
        case kServerInitPlugin:
            OnStartup();
            break;

            // --- Common Crypto

        case 1:
        {
            PEM_From_P12(params);
            break;
        }
        case 2:
            Get_timestamp(params);
            break;
        case 3:
            Get_timestring(params);
            break;
        case 4:
            Get_unixtime(params);
            break;
        case 5:
            MD5(params);
            break;
        case 6:
            RIPEMD160(params);
            break;
        case 7:
            SHA1(params);
            break;
        case 8:
            SHA224(params);
            break;
        case 9:
            SHA256(params);
            break;
        case 10:
            SHA384(params);
            break;
        case 11:
            SHA512(params);
            break;
        case 12:
            SHA512_224(params);
            break;
        case 13:
            SHA512_256(params);
            break;
        case 14:
            RSASHA1(params);
            break;
        case 15:
            RSASHA256(params);
            break;
        case 16:
            RSAVERIFYSHA1(params);
            break;
        case 17:
            RSAVERIFYSHA256(params);
            break;
        case 18:
            AES128(params);
            break;
        case 19:
            AES192(params);
            break;
        case 20:
            AES256(params);
            break;
        case 21:
            SHA3_224(params);
            break;
        case 22:
            SHA3_256(params);
            break;
        case 23:
            SHA3_384(params);
            break;
        case 24:
            SHA3_512(params);
            break;
        case 25:
            SHAKE128(params);
            break;
        case 26:
            SHAKE256(params);
            break;
        case 27:
            HMACMD5(params);
            break;
        case 28:
            HMACSHA1(params);
            break;
        case 29:
            HMACSHA224(params);
            break;
        case 30:
            HMACSHA256(params);
            break;
        case 31:
            HMACSHA384(params);
            break;
        case 32:
            HMACSHA512(params);
            break;
        case 33:
            HMACSHA512_224(params);
            break;
        case 34:
            HMACSHA512_256(params);
            break;
        case 35:
            HMACSHA3_224(params);
            break;
        case 36:
            HMACSHA3_256(params);
            break;
        case 37:
            HMACSHA3_384(params);
            break;
        case 38:
            HMACSHA3_512(params);
            break;

        // case 39:
        //     PBKDF2_HMAC_MD5(params);
        //     break;
        case 39:
            PBKDF2_HMAC_SHA1(params);
            break;

            // case 41:
            //     PBKDF2_HMAC_SHA224(params);
            //     break;
            // case 42:
            //     PBKDF2_HMAC_SHA256(params);
            //     break;
            // case 43:
            //     PBKDF2_HMAC_SHA384(params);
            //     break;
            // case 44:
            //     PBKDF2_HMAC_SHA512(params);
            //     break;

            // case 45:
            //     PBKDF2_HMAC_SHA512_224(params);
            //     break;
            // case 46:
            //     PBKDF2_HMAC_SHA512_256(params);
            //     break;
            // case 47:
            //     PBKDF2_HMAC_SHA3_224(params);
            //     break;
            // case 48:
            //     PBKDF2_HMAC_SHA3_256(params);
            //     break;
            // case 49:
            //     PBKDF2_HMAC_SHA3_384(params);
            //     break;
            // case 50:
            //     PBKDF2_HMAC_SHA3_512(params);
            //     break;
        case 40:
            PEMInfo(params);
            break;

        case 41:
            DERToPEM(params);
            break;
        }
    }
    catch (...)
    {
    }
}

#pragma mark -

// Alistair Bates (bates.a@gmail.com)
// Added Param4 to optionally return all X509 details,
// and return all certificcates in the P12 file

void PEM_From_P12(PA_PluginParameters params)
{

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;

    C_BLOB Param1;
    C_BLOB Param2;
    C_TEXT Param3;
    C_LONGINT Param4; // Options

    C_TEXT returnValue;

    int i;

    Param1.fromParamAtIndex(pParams, 1);
    Param3.fromParamAtIndex(pParams, 3);
    Param4.fromParamAtIndex(pParams, 4);

    BIO *bio = BIO_new_mem_buf((void *)Param1.getBytesPtr(), Param1.getBytesLength());

    if (bio)
    {

        PKCS12 *p12 = d2i_PKCS12_bio(bio, NULL);

        if (p12)
        {

            EVP_PKEY *key = NULL;
            X509 *cert = NULL;
            X509 *xtmp = NULL;
            STACK_OF(X509) *ca = NULL;

            CUTF8String pass;
            Param3.copyUTF8String(&pass);

            if (PKCS12_parse(p12, (const char *)pass.c_str(), &key, &cert, &ca))
            {

                BIO *pem = BIO_new(BIO_s_mem());

                if (pem)
                {

                    if (Param4.getIntValue() & 2)
                    { // Print out X509 details if $4 second bit is 1
                        X509_print(pem, cert);
                    }
                    PEM_write_bio_PrivateKey(pem, key, NULL, NULL, NULL, NULL, (void *)pass.c_str());

                    if (ca && (Param4.getIntValue() & 1))
                    { // Print out all details of Certificate chain if $4 first bit is 1
                        for (i = 0; i < sk_X509_num(ca); i++)
                        {
                            xtmp = sk_X509_value(ca, i);
                            if (Param4.getIntValue() & 2)
                            {
                                X509_print(pem, xtmp);
                            }
                            PEM_write_bio_X509(pem, sk_X509_value(ca, i));
                        }
                    }

                    char *buf = NULL;

                    int len = (int)BIO_get_mem_data(pem, &buf);

                    if (len)
                    {
                        Param2.setBytes((const uint8_t *)buf, len);
                        Param2.toParamAtIndex(pParams, 2);
                        CUTF8String pemStr = CUTF8String((const uint8_t *)buf, len);
                        returnValue.setUTF8String(&pemStr);
                    }

                    BIO_free(pem);
                }
            }
        }

        BIO_free(bio);
    }

    Param2.toParamAtIndex(pParams, 2);
    returnValue.setReturn(pResult);
}

void PEMInfo(PA_PluginParameters params)
{
    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;

    C_BLOB pemBlob; //$1
    //
    C_TEXT returnValue; //$0

    pemBlob.fromParamAtIndex(pParams, 1);

    BIO *pemBIO = BIO_new_mem_buf((void *)pemBlob.getBytesPtr(), pemBlob.getBytesLength());
    BIO *outBIO = BIO_new(BIO_s_mem());

    if (pemBIO)
    {

        X509 *cert;
        cert = PEM_read_bio_X509(pemBIO, NULL, 0, NULL);
        if (cert)
        {

            X509_print(outBIO, cert);
            char *buf = NULL;

            int len = (int)BIO_get_mem_data(outBIO, &buf);

            if (len)
            {
                CUTF8String pemStr = CUTF8String((const uint8_t *)buf, len);
                returnValue.setUTF8String(&pemStr);
            }
            BIO_free(outBIO);
        }

        BIO_free(pemBIO);
    }

    returnValue.setReturn(pResult);
}

void DERToPEM(PA_PluginParameters params)
{
    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;

    C_BLOB derBlob; // $1
    C_BLOB pemBlob; // $2
    //
    C_TEXT returnValue; // $0

    derBlob.fromParamAtIndex(pParams, 1);

    BIO *derBIO = BIO_new_mem_buf((void *)derBlob.getBytesPtr(), derBlob.getBytesLength());
    BIO *pemBIO = BIO_new(BIO_s_mem());
    BIO *outBIO = BIO_new(BIO_s_mem());

    X509 *cert;

    cert = d2i_X509_bio(derBIO, NULL);

    if (cert)
    {
        X509_print(outBIO, cert);

        char *buf = NULL;

        int len = (int)BIO_get_mem_data(outBIO, &buf);

        if (len)
        {
            CUTF8String pemStr = CUTF8String((const uint8_t *)buf, len);
            returnValue.setUTF8String(&pemStr);
        }

        PEM_write_bio_X509(pemBIO, cert);
        if (pemBIO)
        {
            char *buf = NULL;

            int len = (int)BIO_get_mem_data(pemBIO, &buf);

            if (len)
            {
                pemBlob.setBytes((const uint8_t *)buf, len);
                pemBlob.toParamAtIndex(pParams, 2);
            }
            BIO_free(pemBIO);
        }
        BIO_free(outBIO);
    }

    pemBlob.toParamAtIndex(pParams, 2);
    returnValue.setReturn(pResult);
}

void Get_timestamp(PA_PluginParameters params)
{

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    //    PackagePtr pParams = (PackagePtr)params->fParameters;

    C_TEXT returnValue;

    time_t timestamp = time(NULL);
    char ts[256];

#if VERSIONMAC
    setenv("TZ", (const char *)"GMT", 1);
#else
    _wputenv_s(L"TZ", L"GMT");
#endif

    strftime(ts, 256, "%Y-%m-%dT%XZ", localtime(&timestamp));

    returnValue.setUTF8String((const uint8_t *)ts, (uint32_t)strlen(ts));
    returnValue.setReturn(pResult);
}

void Get_timestring(PA_PluginParameters params)
{

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    //    PackagePtr pParams = (PackagePtr)params->fParameters;

    C_TEXT returnValue;

    time_t timestamp = time(NULL);
    char ts[256];

#if VERSIONMAC
    setenv("TZ", (const char *)"GMT", 1);
#else
    _wputenv_s(L"TZ", L"GMT");
#endif

    strftime(ts, 256, "%a, %d %b %y %X %Z", localtime(&timestamp));

    returnValue.setUTF8String((const uint8_t *)ts, (uint32_t)strlen(ts));
    returnValue.setReturn(pResult);
}

void Get_unixtime(PA_PluginParameters params)
{

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    //    PackagePtr pParams = (PackagePtr)params->fParameters;

    C_TEXT returnValue;

    time_t timestamp = time(NULL);
    char ts[256];
    sprintf((char *)ts, "%i", (int)timestamp);

    returnValue.setUTF8String((const uint8_t *)ts, (uint32_t)strlen(ts));
    returnValue.setReturn(pResult);
}

#pragma mark HMAC

void CC_HMACHASH(uint32_t hashlen, const EVP_MD *(*EVP)(void),
                 C_BLOB &Param1,
                 C_BLOB &Param2,
                 C_LONGINT &Param3,
                 C_TEXT &returnValue)
{

    uint8_t *buf = (uint8_t *)calloc(hashlen, sizeof(uint8_t));

    HMAC(EVP(), (const void *)Param1.getBytesPtr(), (int)Param1.getBytesLength(), (const unsigned char *)Param2.getBytesPtr(), (int)Param2.getBytesLength(), buf, &hashlen);

    C_BLOB temp;
    temp.setBytes((const uint8_t *)buf, hashlen);
    switch (Param3.getIntValue())
    {
    case 1:
        temp.toB64Text(&returnValue);
        break;
    case 3:
        temp.toB32Text(&returnValue);
        break;
    case 2:
        temp.toB64Text(&returnValue, true);
        break;
    default:
        temp.toHexText(&returnValue);
        break;
    }

    free(buf);
}

void HMACMD5(PA_PluginParameters params)
{

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;

    C_BLOB Param1;
    C_BLOB Param2;
    C_LONGINT Param3;
    C_TEXT returnValue;

    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    Param3.fromParamAtIndex(pParams, 3);

    CC_HMACHASH(16, EVP_md5, Param1, Param2, Param3, returnValue);

    returnValue.setReturn(pResult);
}

void HMACSHA1(PA_PluginParameters params)
{

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;

    C_BLOB Param1;
    C_BLOB Param2;
    C_LONGINT Param3;
    C_TEXT returnValue;

    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    Param3.fromParamAtIndex(pParams, 3);

    CC_HMACHASH(20, EVP_sha1, Param1, Param2, Param3, returnValue);

    returnValue.setReturn(pResult);
}

void HMACSHA224(PA_PluginParameters params)
{

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;

    C_BLOB Param1;
    C_BLOB Param2;
    C_LONGINT Param3;
    C_TEXT returnValue;

    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    Param3.fromParamAtIndex(pParams, 3);

    CC_HMACHASH(28, EVP_sha224, Param1, Param2, Param3, returnValue);

    returnValue.setReturn(pResult);
}

void HMACSHA256(PA_PluginParameters params)
{

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;

    C_BLOB Param1;
    C_BLOB Param2;
    C_LONGINT Param3;
    C_TEXT returnValue;

    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    Param3.fromParamAtIndex(pParams, 3);

    CC_HMACHASH(32, EVP_sha256, Param1, Param2, Param3, returnValue);

    returnValue.setReturn(pResult);
}

void HMACSHA384(PA_PluginParameters params)
{

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;

    C_BLOB Param1;
    C_BLOB Param2;
    C_LONGINT Param3;
    C_TEXT returnValue;

    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    Param3.fromParamAtIndex(pParams, 3);

    CC_HMACHASH(48, EVP_sha384, Param1, Param2, Param3, returnValue);

    returnValue.setReturn(pResult);
}

void HMACSHA512(PA_PluginParameters params)
{

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;

    C_BLOB Param1;
    C_BLOB Param2;
    C_LONGINT Param3;
    C_TEXT returnValue;

    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    Param3.fromParamAtIndex(pParams, 3);

    CC_HMACHASH(64, EVP_sha512, Param1, Param2, Param3, returnValue);

    returnValue.setReturn(pResult);
}

void HMACSHA512_224(PA_PluginParameters params)
{

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;

    C_BLOB Param1;
    C_BLOB Param2;
    C_LONGINT Param3;
    C_TEXT returnValue;

    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    Param3.fromParamAtIndex(pParams, 3);

    CC_HMACHASH(28, EVP_sha512_224, Param1, Param2, Param3, returnValue);

    returnValue.setReturn(pResult);
}

void HMACSHA512_256(PA_PluginParameters params)
{

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;

    C_BLOB Param1;
    C_BLOB Param2;
    C_LONGINT Param3;
    C_TEXT returnValue;

    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    Param3.fromParamAtIndex(pParams, 3);

    CC_HMACHASH(32, EVP_sha512_256, Param1, Param2, Param3, returnValue);

    returnValue.setReturn(pResult);
}

void HMACSHA3_224(PA_PluginParameters params)
{

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;

    C_BLOB Param1;
    C_BLOB Param2;
    C_LONGINT Param3;
    C_TEXT returnValue;

    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    Param3.fromParamAtIndex(pParams, 3);

    CC_HMACHASH(28, EVP_sha3_224, Param1, Param2, Param3, returnValue);

    returnValue.setReturn(pResult);
}

void HMACSHA3_256(PA_PluginParameters params)
{

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;

    C_BLOB Param1;
    C_BLOB Param2;
    C_LONGINT Param3;
    C_TEXT returnValue;

    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    Param3.fromParamAtIndex(pParams, 3);

    CC_HMACHASH(32, EVP_sha3_256, Param1, Param2, Param3, returnValue);

    returnValue.setReturn(pResult);
}

void HMACSHA3_384(PA_PluginParameters params)
{

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;

    C_BLOB Param1;
    C_BLOB Param2;
    C_LONGINT Param3;
    C_TEXT returnValue;

    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    Param3.fromParamAtIndex(pParams, 3);

    CC_HMACHASH(48, EVP_sha3_384, Param1, Param2, Param3, returnValue);

    returnValue.setReturn(pResult);
}

void HMACSHA3_512(PA_PluginParameters params)
{

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;

    C_BLOB Param1;
    C_BLOB Param2;
    C_LONGINT Param3;
    C_TEXT returnValue;

    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    Param3.fromParamAtIndex(pParams, 3);

    CC_HMACHASH(64, EVP_sha3_512, Param1, Param2, Param3, returnValue);

    returnValue.setReturn(pResult);
}

/* HMAC does not support variable output length digests such as
 EVP_shake128() and EVP_shake256(). */

#pragma mark HASH

void CC_HASH(unsigned int hashlen, void (*CC)(const void *data, uint32_t len, unsigned char *md),
             C_BLOB &Param1,
             C_LONGINT &Param2,
             C_TEXT &returnValue)
{

    uint8_t *buf = (uint8_t *)calloc(hashlen, sizeof(uint8_t));

    CC((unsigned char *)Param1.getBytesPtr(), Param1.getBytesLength(), buf);

    C_BLOB temp;
    temp.setBytes((const uint8_t *)buf, hashlen);
    switch (Param2.getIntValue())
    {
    case 1:
        temp.toB64Text(&returnValue);
        break;
    case 3:
        temp.toB32Text(&returnValue);
        break;
    case 2:
        temp.toB64Text(&returnValue, true);
        break;
    default:
        temp.toHexText(&returnValue);
        break;
    }

    free(buf);
}

void CC_HASH_XOF(unsigned int hashlen, void (*CC)(const void *data, uint32_t len, uint32_t mdlen, unsigned char *md),
                 C_BLOB &Param1,
                 C_LONGINT &Param2,
                 C_TEXT &returnValue)
{

    uint8_t *buf = (uint8_t *)calloc(hashlen, sizeof(uint8_t));

    CC((unsigned char *)Param1.getBytesPtr(), Param1.getBytesLength(), hashlen, buf);

    C_BLOB temp;
    temp.setBytes((const uint8_t *)buf, hashlen);
    switch (Param2.getIntValue())
    {
    case 1:
        temp.toB64Text(&returnValue);
        break;
    case 3:
        temp.toB32Text(&returnValue);
        break;
    case 2:
        temp.toB64Text(&returnValue, true);
        break;
    default:
        temp.toHexText(&returnValue);
        break;
    }

    free(buf);
}

void MD5(PA_PluginParameters params)
{

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;

    C_BLOB Param1;
    C_LONGINT Param2;
    C_TEXT returnValue;

    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);

    CC_HASH(16, CC_MD5, Param1, Param2, returnValue);

    returnValue.setReturn(pResult);
}

void SHA1(PA_PluginParameters params)
{

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;

    C_BLOB Param1;
    C_LONGINT Param2;
    C_TEXT returnValue;

    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);

    CC_HASH(20, CC_SHA1, Param1, Param2, returnValue);

    returnValue.setReturn(pResult);
}

#pragma mark AES

void CC_AES(const EVP_CIPHER *cipher,
            C_BLOB &Param1,
            C_BLOB &Param2,
            C_LONGINT &Param3,
            C_LONGINT &Param5,
            C_LONGINT &Param6,
            C_BLOB &Param7,
            C_BLOB &Param8,
            C_TEXT &returnValue)
{

    EVP_CIPHER_CTX *ctx = EVP_CIPHER_CTX_new();

    unsigned char key[EVP_MAX_KEY_LENGTH], iv[EVP_MAX_IV_LENGTH];

    const unsigned char *source = (const unsigned char *)Param1.getBytesPtr();
    int source_len = Param1.getBytesLength();
    int crypted_len, tail_len;

    bool key_and_iv_is_valid = false;

    if (!Param2.getBytesLength() && Param7.getBytesLength() && Param8.getBytesLength() && Param7.getBytesLength() <= EVP_MAX_KEY_LENGTH && Param8.getBytesLength() <= EVP_MAX_IV_LENGTH)
    {
        memset(key, 0, EVP_MAX_KEY_LENGTH);
        memset(iv, 0, EVP_MAX_IV_LENGTH);
        memcpy(key, Param7.getBytesPtr(), Param7.getBytesLength());
        memcpy(iv, Param8.getBytesPtr(), Param8.getBytesLength());
        key_and_iv_is_valid = true;
    }
    else
    {
        // passphrase -> key, iv
        key_and_iv_is_valid = (EVP_BytesToKey(cipher, EVP_md5(), NULL,
                                              Param2.getBytesPtr(), Param2.getBytesLength(),
                                              2048, key, iv) > 0);
    }

    if (key_and_iv_is_valid)
    {
        if (EVP_CipherInit(ctx, cipher, key, iv, 0 == Param3.getIntValue()))
        {
            if (Param6.getIntValue())
            {
                EVP_CIPHER_CTX_set_padding(ctx, 0);
            }
            size_t buf_size = source_len + EVP_MAX_BLOCK_LENGTH;
            unsigned char *buf = (unsigned char *)calloc(buf_size, sizeof(unsigned char));
            if (EVP_CipherUpdate(ctx, buf, &crypted_len, source, source_len))
            {
                if (EVP_CipherFinal(ctx, (buf + crypted_len), &tail_len))
                {
                    crypted_len += tail_len;
                    C_BLOB temp;
                    temp.setBytes((const uint8_t *)buf, crypted_len);

                    switch (Param5.getIntValue())
                    {
                    case 1:
                        temp.toB64Text(&returnValue);
                        break;
                    case 3:
                        temp.toB32Text(&returnValue);
                        break;
                    case 2:
                        temp.toB64Text(&returnValue, true);
                        break;
                    default:
                        temp.toHexText(&returnValue);
                        break;
                    }
                }
            }
            free(buf);
        }
        EVP_CIPHER_CTX_free(ctx);
    }
}

void AES128(PA_PluginParameters params)
{

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;

    C_BLOB Param1;
    C_BLOB Param2;
    C_LONGINT Param3;
    C_LONGINT Param4;
    C_LONGINT Param5;
    C_LONGINT Param6;
    C_BLOB Param7;
    C_BLOB Param8;
    C_TEXT returnValue;

    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    Param3.fromParamAtIndex(pParams, 3);
    Param4.fromParamAtIndex(pParams, 4);
    Param5.fromParamAtIndex(pParams, 5);
    Param6.fromParamAtIndex(pParams, 6);
    Param7.fromParamAtIndex(pParams, 7);
    Param8.fromParamAtIndex(pParams, 8);

    const EVP_CIPHER *cipher;

    switch (Param4.getIntValue())
    {
    case 0:
        cipher = EVP_aes_128_ecb();
        break;
    case 1:
        cipher = EVP_aes_128_cbc();
        break;
    case 2:
        cipher = EVP_aes_128_cfb1();
        break;
    case 3:
        cipher = EVP_aes_128_cfb8();
        break;
    case 4:
        cipher = EVP_aes_128_cfb128();
        break;
    case 5:
        cipher = EVP_aes_128_ofb();
        break;
    case 6:
        cipher = EVP_aes_128_ctr();
        break;
    case 7:
        cipher = EVP_aes_128_gcm();
        break;
    case 8:
        cipher = EVP_aes_128_ccm();
        break;
    case 9:
        cipher = EVP_aes_128_xts();
        break;
    default:
        cipher = EVP_aes_128_ecb();
        break;
    }

    CC_AES(cipher, Param1, Param2, Param3, Param5, Param6, Param7, Param8, returnValue);

    returnValue.setReturn(pResult);
}

void AES192(PA_PluginParameters params)
{

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;

    C_BLOB Param1;
    C_BLOB Param2;
    C_LONGINT Param3;
    C_LONGINT Param4;
    C_LONGINT Param5;
    C_LONGINT Param6;
    C_BLOB Param7;
    C_BLOB Param8;
    C_TEXT returnValue;

    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    Param3.fromParamAtIndex(pParams, 3);
    Param4.fromParamAtIndex(pParams, 4);
    Param5.fromParamAtIndex(pParams, 5);
    Param6.fromParamAtIndex(pParams, 6);
    Param7.fromParamAtIndex(pParams, 7);
    Param8.fromParamAtIndex(pParams, 8);

    const EVP_CIPHER *cipher;

    switch (Param4.getIntValue())
    {
    case 0:
        cipher = EVP_aes_192_ecb();
        break;
    case 1:
        cipher = EVP_aes_192_cbc();
        break;
    case 2:
        cipher = EVP_aes_192_cfb1();
        break;
    case 3:
        cipher = EVP_aes_192_cfb8();
        break;
    case 4:
        cipher = EVP_aes_192_cfb128();
        break;
    case 5:
        cipher = EVP_aes_192_ofb();
        break;
    case 6:
        cipher = EVP_aes_192_ctr();
        break;
    case 7:
        cipher = EVP_aes_192_gcm();
        break;
    case 8:
        cipher = EVP_aes_192_ccm();
        break;
    default:
        cipher = EVP_aes_192_ecb();
        break;
    }

    CC_AES(cipher, Param1, Param2, Param3, Param5, Param6, Param7, Param8, returnValue);

    returnValue.setReturn(pResult);
}

void AES256(PA_PluginParameters params)
{

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;

    C_BLOB Param1;
    C_BLOB Param2;
    C_LONGINT Param3;
    C_LONGINT Param4;
    C_LONGINT Param5;
    C_LONGINT Param6;
    C_BLOB Param7;
    C_BLOB Param8;
    C_TEXT returnValue;

    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    Param3.fromParamAtIndex(pParams, 3);
    Param4.fromParamAtIndex(pParams, 4);
    Param5.fromParamAtIndex(pParams, 5);
    Param6.fromParamAtIndex(pParams, 6);
    Param7.fromParamAtIndex(pParams, 7);
    Param8.fromParamAtIndex(pParams, 8);

    const EVP_CIPHER *cipher;

    switch (Param4.getIntValue())
    {
    case 0:
        cipher = EVP_aes_256_ecb();
        break;
    case 1:
        cipher = EVP_aes_256_cbc();
        break;
    case 2:
        cipher = EVP_aes_256_cfb1();
        break;
    case 3:
        cipher = EVP_aes_256_cfb8();
        break;
    case 4:
        cipher = EVP_aes_256_cfb128();
        break;
    case 5:
        cipher = EVP_aes_256_ofb();
        break;
    case 6:
        cipher = EVP_aes_256_ctr();
        break;
    case 7:
        cipher = EVP_aes_256_gcm();
        break;
    case 8:
        cipher = EVP_aes_256_ccm();
        break;
    case 9:
        cipher = EVP_aes_256_xts();
        break;
    default:
        cipher = EVP_aes_256_ecb();
        break;
    }

    CC_AES(cipher, Param1, Param2, Param3, Param5, Param6, Param7, Param8, returnValue);

    returnValue.setReturn(pResult);
}

#pragma mark PBKDF2

void CC_PBKDF2(unsigned int hashlen, const EVP_MD *digest,
               C_BLOB &Param1, C_BLOB &Param2,
               C_LONGINT &Param3, C_LONGINT &Param4,
               C_TEXT &returnValue)
{

    uint8_t *buf = (uint8_t *)calloc(hashlen, sizeof(uint8_t));

    PKCS5_PBKDF2_HMAC((const char *)Param1.getBytesPtr(),
                      Param1.getBytesLength(),
                      (const unsigned char *)Param2.getBytesPtr(),
                      Param2.getBytesLength(),
                      Param3.getIntValue(),
                      digest,
                      hashlen,
                      (unsigned char *)buf);

    C_BLOB temp;
    temp.setBytes((const uint8_t *)buf, hashlen);

    switch (Param4.getIntValue())
    {
    case 1:
        temp.toB64Text(&returnValue);
        break;
    case 3:
        temp.toB32Text(&returnValue);
        break;
    case 2:
        temp.toB64Text(&returnValue, true);
        break;
    default:
        temp.toHexText(&returnValue);
        break;
    }

    free(buf);
}

void PBKDF2_HMAC_MD5(PA_PluginParameters params)
{

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;

    C_BLOB Param1;
    C_BLOB Param2;

    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);

    C_LONGINT Param3;
    C_LONGINT Param4;

    Param3.fromParamAtIndex(pParams, 3);
    Param4.fromParamAtIndex(pParams, 4);

    C_TEXT returnValue;

    CC_PBKDF2(16, EVP_md5(), Param1, Param2, Param3, Param4, returnValue);

    returnValue.setReturn(pResult);
}

void PBKDF2_HMAC_SHA1(PA_PluginParameters params)
{

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;

    C_BLOB Param1;
    C_BLOB Param2;

    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);

    C_LONGINT Param3;
    C_LONGINT Param4;

    Param3.fromParamAtIndex(pParams, 3);
    Param4.fromParamAtIndex(pParams, 4);

    C_TEXT returnValue;

    CC_PBKDF2(20, EVP_sha1(), Param1, Param2, Param3, Param4, returnValue);

    returnValue.setReturn(pResult);
}

void PBKDF2_HMAC_SHA224(PA_PluginParameters params)
{

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;

    C_BLOB Param1;
    C_BLOB Param2;

    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);

    C_LONGINT Param3;
    C_LONGINT Param4;

    Param3.fromParamAtIndex(pParams, 3);
    Param4.fromParamAtIndex(pParams, 4);

    C_TEXT returnValue;

    CC_PBKDF2(28, EVP_sha224(), Param1, Param2, Param3, Param4, returnValue);

    returnValue.setReturn(pResult);
}

void PBKDF2_HMAC_SHA256(PA_PluginParameters params)
{

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;

    C_BLOB Param1;
    C_BLOB Param2;

    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);

    C_LONGINT Param3;
    C_LONGINT Param4;

    Param3.fromParamAtIndex(pParams, 3);
    Param4.fromParamAtIndex(pParams, 4);

    C_TEXT returnValue;

    CC_PBKDF2(32, EVP_sha256(), Param1, Param2, Param3, Param4, returnValue);

    returnValue.setReturn(pResult);
}

void PBKDF2_HMAC_SHA384(PA_PluginParameters params)
{

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;

    C_BLOB Param1;
    C_BLOB Param2;

    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);

    C_LONGINT Param3;
    C_LONGINT Param4;

    Param3.fromParamAtIndex(pParams, 3);
    Param4.fromParamAtIndex(pParams, 4);

    C_TEXT returnValue;

    CC_PBKDF2(48, EVP_sha384(), Param1, Param2, Param3, Param4, returnValue);

    returnValue.setReturn(pResult);
}
void PBKDF2_HMAC_SHA512(PA_PluginParameters params)
{

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;

    C_BLOB Param1;
    C_BLOB Param2;

    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);

    C_LONGINT Param3;
    C_LONGINT Param4;

    Param3.fromParamAtIndex(pParams, 3);
    Param4.fromParamAtIndex(pParams, 4);

    C_TEXT returnValue;

    CC_PBKDF2(64, EVP_sha512(), Param1, Param2, Param3, Param4, returnValue);

    returnValue.setReturn(pResult);
}

void PBKDF2_HMAC_SHA512_224(PA_PluginParameters params)
{

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;

    C_BLOB Param1;
    C_BLOB Param2;

    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);

    C_LONGINT Param3;
    C_LONGINT Param4;

    Param3.fromParamAtIndex(pParams, 3);
    Param4.fromParamAtIndex(pParams, 4);

    C_TEXT returnValue;

    CC_PBKDF2(28, EVP_sha512_224(), Param1, Param2, Param3, Param4, returnValue);

    returnValue.setReturn(pResult);
}

void PBKDF2_HMAC_SHA512_256(PA_PluginParameters params)
{

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;

    C_BLOB Param1;
    C_BLOB Param2;

    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);

    C_LONGINT Param3;
    C_LONGINT Param4;

    Param3.fromParamAtIndex(pParams, 3);
    Param4.fromParamAtIndex(pParams, 4);

    C_TEXT returnValue;

    CC_PBKDF2(32, EVP_sha512_256(), Param1, Param2, Param3, Param4, returnValue);

    returnValue.setReturn(pResult);
}

void PBKDF2_HMAC_SHA3_224(PA_PluginParameters params)
{

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;

    C_BLOB Param1;
    C_BLOB Param2;

    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);

    C_LONGINT Param3;
    C_LONGINT Param4;

    Param3.fromParamAtIndex(pParams, 3);
    Param4.fromParamAtIndex(pParams, 4);

    C_TEXT returnValue;

    CC_PBKDF2(28, EVP_sha3_224(), Param1, Param2, Param3, Param4, returnValue);

    returnValue.setReturn(pResult);
}

void PBKDF2_HMAC_SHA3_256(PA_PluginParameters params)
{

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;

    C_BLOB Param1;
    C_BLOB Param2;

    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);

    C_LONGINT Param3;
    C_LONGINT Param4;

    Param3.fromParamAtIndex(pParams, 3);
    Param4.fromParamAtIndex(pParams, 4);

    C_TEXT returnValue;

    CC_PBKDF2(32, EVP_sha3_256(), Param1, Param2, Param3, Param4, returnValue);

    returnValue.setReturn(pResult);
}

void PBKDF2_HMAC_SHA3_384(PA_PluginParameters params)
{

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;

    C_BLOB Param1;
    C_BLOB Param2;

    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);

    C_LONGINT Param3;
    C_LONGINT Param4;

    Param3.fromParamAtIndex(pParams, 3);
    Param4.fromParamAtIndex(pParams, 4);

    C_TEXT returnValue;

    CC_PBKDF2(48, EVP_sha3_384(), Param1, Param2, Param3, Param4, returnValue);

    returnValue.setReturn(pResult);
}

void PBKDF2_HMAC_SHA3_512(PA_PluginParameters params)
{

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;

    C_BLOB Param1;
    C_BLOB Param2;

    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);

    C_LONGINT Param3;
    C_LONGINT Param4;

    Param3.fromParamAtIndex(pParams, 3);
    Param4.fromParamAtIndex(pParams, 4);

    C_TEXT returnValue;

    CC_PBKDF2(64, EVP_sha3_512(), Param1, Param2, Param3, Param4, returnValue);

    returnValue.setReturn(pResult);
}

#pragma mark RIPEMD

void RIPEMD160(PA_PluginParameters params)
{

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;

    C_BLOB Param1;
    C_LONGINT Param2;
    C_TEXT returnValue;

    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);

    uint8_t *buf = (uint8_t *)calloc(20, sizeof(uint8_t));

    CC_RIPEMD160((unsigned char *)Param1.getBytesPtr(), Param1.getBytesLength(), buf);

    C_BLOB temp;
    temp.setBytes((const uint8_t *)buf, 20);

    switch (Param2.getIntValue())
    {
    case 1:
        temp.toB64Text(&returnValue);
        break;
    case 3:
        temp.toB32Text(&returnValue);
        break;
    case 2:
        temp.toB64Text(&returnValue, true);
        break;
    default:
        temp.toHexText(&returnValue);
        break;
    }

    free(buf);

    returnValue.setReturn(pResult);
}

#pragma mark RSA

void CC_RSASHA(unsigned int hashlen, int nid, void (*CC)(const void *data, uint32_t len, unsigned char *md),
               C_BLOB &Param1,
               C_BLOB &Param2,
               C_LONGINT &Param3,
               C_TEXT &returnValue)
{

    uint8_t *buf = (uint8_t *)calloc(hashlen, sizeof(uint8_t));
    unsigned int signatureLength = 0;

    CC((unsigned char *)Param1.getBytesPtr(), Param1.getBytesLength(), buf);
    BIO *bio = BIO_new_mem_buf((void *)Param2.getBytesPtr(), Param2.getBytesLength());

    if (bio)
    {
        RSA *key = NULL;
        key = PEM_read_bio_RSAPrivateKey(bio, NULL, NULL, NULL);
        if (key)
        {
            uint8_t *sgn = (uint8_t *)calloc(RSA_size(key), sizeof(uint8_t));
            if (RSA_sign(nid, buf, hashlen, sgn, &signatureLength, key))
            {
                C_BLOB temp;
                temp.setBytes((const uint8_t *)sgn, signatureLength);
                switch (Param3.getIntValue())
                {
                case 1:
                    temp.toB64Text(&returnValue);
                    break;
                case 3:
                    temp.toB32Text(&returnValue);
                    break;
                case 2:
                    temp.toB64Text(&returnValue, true);
                    break;
                default:
                    temp.toHexText(&returnValue);
                    break;
                }
            }
            free(sgn);
        }
        BIO_free(bio);
    }
    free(buf);
}

void RSASHA1(PA_PluginParameters params)
{

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;

    C_BLOB Param1;
    C_BLOB Param2;
    C_LONGINT Param3;
    C_TEXT returnValue;

    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    Param3.fromParamAtIndex(pParams, 3);

    CC_RSASHA(20, NID_sha1, CC_SHA1, Param1, Param2, Param3, returnValue);

    returnValue.setReturn(pResult);
}

void RSASHA256(PA_PluginParameters params)
{

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;

    C_BLOB Param1;
    C_BLOB Param2;
    C_LONGINT Param3;
    C_TEXT returnValue;

    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    Param3.fromParamAtIndex(pParams, 3);

    CC_RSASHA(32, NID_sha256, CC_SHA256, Param1, Param2, Param3, returnValue);

    returnValue.setReturn(pResult);
}

void CC_RSASHAVERIFY(unsigned int hashlen, int nid, void (*CC)(const void *data, uint32_t len, unsigned char *md),
                     C_BLOB &Param1,
                     C_BLOB &Param2,
                     C_TEXT &Param3,
                     C_LONGINT &Param4,
                     C_LONGINT &returnValue)
{

    uint8_t *buf = (uint8_t *)calloc(hashlen, sizeof(uint8_t));

    CC((unsigned char *)Param1.getBytesPtr(), Param1.getBytesLength(), buf);
    BIO *bio = BIO_new_mem_buf((void *)Param2.getBytesPtr(), Param2.getBytesLength());

    if (bio)
    {
        RSA *key = NULL;
        key = PEM_read_bio_RSA_PUBKEY(bio, NULL, NULL, NULL);
        if (key)
        {
            C_BLOB temp;

            switch (Param4.getIntValue())
            {
            case 1:
                temp.fromB64Text(&Param3);
                break;
            default:
                temp.fromHexText(&Param3);
                break;
            }

            if (RSA_verify(nid, buf, hashlen, (unsigned char *)temp.getBytesPtr(), temp.getBytesLength(), key))
            {
                returnValue.setIntValue(1);
            }
        }
        BIO_free(bio);
    }
    free(buf);
}

void RSAVERIFYSHA1(PA_PluginParameters params)
{

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;

    C_BLOB Param1;
    C_BLOB Param2;
    C_TEXT Param3;
    C_LONGINT Param4;
    C_LONGINT returnValue;

    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    Param3.fromParamAtIndex(pParams, 3);
    Param4.fromParamAtIndex(pParams, 4);

    CC_RSASHAVERIFY(20, NID_sha1, CC_SHA1, Param1, Param2, Param3, Param4, returnValue);

    returnValue.setReturn(pResult);
}

void RSAVERIFYSHA256(PA_PluginParameters params)
{

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;

    C_BLOB Param1;
    C_BLOB Param2;
    C_TEXT Param3;
    C_LONGINT Param4;
    C_LONGINT returnValue;

    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    Param3.fromParamAtIndex(pParams, 3);
    Param4.fromParamAtIndex(pParams, 4);

    CC_RSASHAVERIFY(32, NID_sha256, CC_SHA256, Param1, Param2, Param3, Param4, returnValue);

    returnValue.setReturn(pResult);
}

#pragma mark SHA-2

void SHA224(PA_PluginParameters params)
{

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;

    C_BLOB Param1;
    C_LONGINT Param2;
    C_TEXT returnValue;

    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);

    CC_HASH(28, CC_SHA224, Param1, Param2, returnValue);

    returnValue.setReturn(pResult);
}

void SHA256(PA_PluginParameters params)
{

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;

    C_BLOB Param1;
    C_LONGINT Param2;
    C_TEXT returnValue;

    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);

    CC_HASH(32, CC_SHA256, Param1, Param2, returnValue);

    returnValue.setReturn(pResult);
}

void SHA384(PA_PluginParameters params)
{

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;

    C_BLOB Param1;
    C_LONGINT Param2;
    C_TEXT returnValue;

    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);

    CC_HASH(48, CC_SHA384, Param1, Param2, returnValue);

    returnValue.setReturn(pResult);
}

void SHA512(PA_PluginParameters params)
{

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;

    C_BLOB Param1;
    C_LONGINT Param2;
    C_TEXT returnValue;

    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);

    CC_HASH(64, CC_SHA512, Param1, Param2, returnValue);

    returnValue.setReturn(pResult);
}

void SHA512_224(PA_PluginParameters params)
{

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;

    C_BLOB Param1;
    C_LONGINT Param2;
    C_TEXT returnValue;

    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);

    CC_HASH(28, CC_SHA512_224, Param1, Param2, returnValue);

    returnValue.setReturn(pResult);
}

void SHA512_256(PA_PluginParameters params)
{

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;

    C_BLOB Param1;
    C_LONGINT Param2;
    C_TEXT returnValue;

    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);

    CC_HASH(32, CC_SHA512_256, Param1, Param2, returnValue);

    returnValue.setReturn(pResult);
}

#pragma mark SHA-3

void SHA3_224(PA_PluginParameters params)
{

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;

    C_BLOB Param1;
    C_LONGINT Param2;
    C_TEXT returnValue;

    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);

    CC_HASH(28, CC_SHA3_224, Param1, Param2, returnValue);

    returnValue.setReturn(pResult);
}

void SHA3_256(PA_PluginParameters params)
{

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;

    C_BLOB Param1;
    C_LONGINT Param2;
    C_TEXT returnValue;

    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);

    CC_HASH(32, CC_SHA3_256, Param1, Param2, returnValue);

    returnValue.setReturn(pResult);
}

void SHA3_384(PA_PluginParameters params)
{

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;

    C_BLOB Param1;
    C_LONGINT Param2;
    C_TEXT returnValue;

    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);

    CC_HASH(48, CC_SHA3_384, Param1, Param2, returnValue);

    returnValue.setReturn(pResult);
}

void SHA3_512(PA_PluginParameters params)
{

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;

    C_BLOB Param1;
    C_LONGINT Param2;
    C_TEXT returnValue;

    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);

    CC_HASH(64, CC_SHA3_512, Param1, Param2, returnValue);

    returnValue.setReturn(pResult);
}

void SHAKE128(PA_PluginParameters params)
{

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;

    C_BLOB Param1;
    C_LONGINT Param2;
    C_LONGINT Param3;
    C_TEXT returnValue;

    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    Param3.fromParamAtIndex(pParams, 3);

    unsigned int hashlen = Param2.getIntValue();
    div_t d = div(hashlen, 4);
    hashlen = d.quot + (d.rem == 0 ? 0 : 1);

    CC_HASH_XOF(hashlen, CC_SHAKE128, Param1, Param2, returnValue);

    returnValue.setReturn(pResult);
}

void SHAKE256(PA_PluginParameters params)
{

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;

    C_BLOB Param1;
    C_LONGINT Param2;
    C_LONGINT Param3;
    C_TEXT returnValue;

    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    Param3.fromParamAtIndex(pParams, 3);

    unsigned int hashlen = Param2.getIntValue();
    hashlen = hashlen / 4 + ((hashlen % 4) == 0 ? 0 : 4);

    CC_HASH_XOF(hashlen, CC_SHAKE256, Param1, Param2, returnValue);

    returnValue.setReturn(pResult);
}
