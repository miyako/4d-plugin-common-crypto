/* --------------------------------------------------------------------------------
 #
 #  4DPlugin-Common-Crypto.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : Common Crypto
 #	author : miyako
 #	2019/08/16
 #  
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-Common-Crypto.h"

#ifndef _CC_COMMON_HMAC_H_

void CC_EVP(const EVP_MD *evp, uint32_t mlen, const void *data, uint32_t len, unsigned char *md) {
    
    unsigned int mdlen = mlen;
    EVP_MD_CTX* c = EVP_MD_CTX_new();
    EVP_MD_CTX_reset(c);
    EVP_DigestInit(c, evp);
    EVP_DigestUpdate(c, data, len);
    EVP_DigestFinal(c, md, &mdlen);
    EVP_MD_CTX_free(c);
}

void CC_EVP_XOF(const EVP_MD *evp, uint32_t mlen, const void *data, uint32_t len, unsigned char *md) {
    
    unsigned int mdlen = mlen;
    EVP_MD_CTX* c = EVP_MD_CTX_new();
    EVP_MD_CTX_reset(c);
    EVP_DigestInit(c, evp);
    EVP_DigestUpdate(c, data, len);
    EVP_DigestFinalXOF(c, md, mdlen);
    EVP_MD_CTX_free(c);
}

void CC_MD5(const void *data, uint32_t len, unsigned char *md)
{
    CC_EVP(EVP_md5(), 16, data, len, md);
}

void CC_SHA1(const void *data, uint32_t len, unsigned char *md)
{
    CC_EVP(EVP_sha1(), 20, data, len, md);
}

void CC_SHA224(const void *data, uint32_t len, unsigned char *md)
{
    CC_EVP(EVP_sha224(), 28, data, len, md);
}

void CC_SHA256(const void *data, uint32_t len, unsigned char *md)
{
    CC_EVP(EVP_sha256(), 32, data, len, md);
}

void CC_SHA384(const void *data, uint32_t len, unsigned char *md)
{
    CC_EVP(EVP_sha384(), 48, data, len, md);
}

void CC_SHA512(const void *data, uint32_t len, unsigned char *md)
{
    CC_EVP(EVP_sha512(), 64, data, len, md);
}

void CC_SHA512_224(const void *data, uint32_t len, unsigned char *md)
{
    CC_EVP(EVP_sha512_224(), 28, data, len, md);
}

void CC_SHA512_256(const void *data, uint32_t len, unsigned char *md)
{
    CC_EVP(EVP_sha512_256(), 32, data, len, md);
}

//SHA3

void CC_SHA3_224(const void *data, uint32_t len, unsigned char *md)
{
    CC_EVP(EVP_sha3_224(), 28, data, len, md);
}

void CC_SHA3_256(const void *data, uint32_t len, unsigned char *md)
{
    CC_EVP(EVP_sha3_256(), 32, data, len, md);
}

void CC_SHA3_384(const void *data, uint32_t len, unsigned char *md)
{
    CC_EVP(EVP_sha3_384(), 48, data, len, md);
}

void CC_SHA3_512(const void *data, uint32_t len, unsigned char *md)
{
    CC_EVP(EVP_sha3_512(), 64, data, len, md);
}

void CC_SHAKE128(const void *data, uint32_t len, unsigned char *md)
{
    CC_EVP_XOF(EVP_shake128(), 32, data, len, md);

}

void CC_SHAKE256(const void *data, uint32_t len, unsigned char *md)
{
    CC_EVP_XOF(EVP_shake256(), 64, data, len, md);
}

//RIPEMD

void CC_RIPEMD160(const void *data, uint32_t len, unsigned char *md)
{
    CC_EVP(EVP_ripemd160(), 20, data, len, md);
}

#endif

#pragma mark -

void OnStartup() {
    OPENSSL_init_crypto(OPENSSL_INIT_ADD_ALL_CIPHERS \
                        | OPENSSL_INIT_ADD_ALL_DIGESTS, NULL);//for PEM_From_P12
}

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
	try
	{
        switch(selector)
        {
            case kInitPlugin :
            case kServerInitPlugin :
            OnStartup();
            break;
            
            // --- Common Crypto
            
            case 1 :
            PEM_From_P12(params);
            break;
            case 2 :
        Get_timestamp(params);
            break;
            case 3 :
        Get_timestring(params);
            break;
            case 4 :
        Get_unixtime(params);
            break;
            case 5 :
            MD5(params);
            break;
            case 6 :
            RIPEMD160(params);
            break;
            case 7 :
            SHA1(params);
            break;
            case 8 :
            SHA224(params);
            break;
            case 9 :
            SHA256(params);
            break;
            case 10 :
            SHA384(params);
            break;
            case 11 :
            SHA512(params);
            break;
            case 12 :
            SHA512_224(params);
            break;
            case 13 :
            SHA512_256(params);
            break;
            case 14 :
            RSASHA1(params);
            break;
            case 15 :
            RSASHA256(params);
            break;
            case 16 :
            RSAVERIFYSHA1(params);
            break;
            case 17 :
            RSAVERIFYSHA256(params);
            break;
            case 18 :
            AES128(params);
            break;
            case 19 :
            AES192(params);
            break;
            case 20 :
            AES256(params);
            break;
            case 21 :
            SHA3_224(params);
            break;
            case 22 :
            SHA3_256(params);
            break;
            case 23 :
            SHA3_384(params);
            break;
            case 24 :
            SHA3_512(params);
            break;
            case 25 :
            SHAKE128(params);
            break;
            case 26 :
            SHAKE256(params);
            break;
            case 27 :
            HMACMD5(params);
            break;
            case 28 :
            HMACSHA1(params);
            break;
            case 29 :
            HMACSHA224(params);
            break;
            case 30 :
            HMACSHA256(params);
            break;
            case 31 :
            HMACSHA384(params);
            break;
            case 32 :
            HMACSHA512(params);
            break;
            case 33 :
            HMACSHA512_224(params);
            break;
            case 34 :
            HMACSHA512_256(params);
            break;
            case 35 :
            HMACSHA3_224(params);
            break;
            case 36 :
            HMACSHA3_256(params);
            break;
            case 37 :
            HMACSHA3_384(params);
            break;
            case 38 :
            HMACSHA3_512(params);
            break;
        }

	}
	catch(...)
	{

	}
}

#pragma mark -

void PEM_From_P12(PA_PluginParameters params) {
    
    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_BLOB Param1;
    C_BLOB Param2;
    C_TEXT Param3;
    C_TEXT returnValue;
    
    Param1.fromParamAtIndex(pParams, 1);
    Param3.fromParamAtIndex(pParams, 3);
    
    BIO *bio = BIO_new_mem_buf((void *)Param1.getBytesPtr(), Param1.getBytesLength());
    
    if(bio){
        
        PKCS12 *p12 = d2i_PKCS12_bio(bio, NULL);
        
        if(p12){
            
            EVP_PKEY *key = NULL;
            X509 *cert = NULL;
            STACK_OF(X509) *ca = NULL;
            
            CUTF8String pass;
            Param3.copyUTF8String(&pass);
            
            if(PKCS12_parse(p12, (const char *)pass.c_str(), &key, &cert, &ca)){
                
                BIO *pem = BIO_new(BIO_s_mem());
                
                if(pem){
                    
                    PEM_write_bio_PrivateKey(pem, key, NULL, NULL, NULL, NULL, (void *)pass.c_str());
                    
                    char *buf = NULL;
                    
                    int len = (int)BIO_get_mem_data(pem, &buf);
                    
                    if(len){
                        Param2.setBytes((const uint8_t *)buf, len);
                        Param2.toParamAtIndex(pParams, 2);
                        CUTF8String pemStr = CUTF8String((const uint8_t *)buf, len);
                        returnValue.setUTF8String(&pemStr);
                    }
                    
                    BIO_free(pem);
                    
                }
            }
        }
        
        BIO_free(bio);
        
    }
    
    Param2.toParamAtIndex(pParams, 2);
    returnValue.setReturn(pResult);
}

void Get_timestamp(PA_PluginParameters params) {
    
    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
//    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_TEXT returnValue;
    
    time_t timestamp = time(NULL);
    char ts[256];
    
#if VERSIONMAC
    setenv("TZ",(const char *)"GMT", 1);
#else
    _wputenv_s(L"TZ",L"GMT");
#endif
    
    strftime(ts, 256, "%Y-%m-%dT%XZ",  localtime(&timestamp));
    
    returnValue.setUTF8String((const uint8_t*)ts, (uint32_t)strlen(ts));
    returnValue.setReturn(pResult);
}

void Get_timestring(PA_PluginParameters params) {
    
    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
//    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_TEXT returnValue;
    
    time_t timestamp = time(NULL);
    char ts[256];
    
#if VERSIONMAC
    setenv("TZ",(const char *)"GMT", 1);
#else
    _wputenv_s(L"TZ",L"GMT");
#endif
    
    strftime(ts, 256, "%a, %d %b %y %X %Z",  localtime(&timestamp));
    
    returnValue.setUTF8String((const uint8_t*)ts, (uint32_t)strlen(ts));
    returnValue.setReturn(pResult);
}

void Get_unixtime(PA_PluginParameters params) {
    
    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
//    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_TEXT returnValue;
    
    time_t timestamp = time(NULL);
    char ts[256];
    sprintf((char *)ts, "%i", (int)timestamp);
    
    returnValue.setUTF8String((const uint8_t*)ts, (uint32_t)strlen(ts));
    returnValue.setReturn(pResult);
}

#pragma mark HMAC

void CC_HMACHASH(uint32_t hashlen, const EVP_MD * (*EVP)(void),
                 C_BLOB &Param1,
                 C_BLOB &Param2,
                 C_LONGINT &Param3,
                 C_TEXT &returnValue) {
    
    uint8_t *buf = (uint8_t *)calloc(hashlen, sizeof(uint8_t));
    
    HMAC(EVP(), (const void *)Param1.getBytesPtr(), (int)Param1.getBytesLength(), (const unsigned char *)Param2.getBytesPtr(), (int)Param2.getBytesLength(), buf, &hashlen);
    
    C_BLOB temp;
    temp.setBytes((const uint8_t *)buf, hashlen);
    switch (Param3.getIntValue())
    {
        case 1:
        temp.toB64Text(&returnValue);
        break;
        case 2:
        temp.toB64Text(&returnValue, true);
        break;
        default:
        temp.toHexText(&returnValue);
        break;
    }
    
    free(buf);
}

void HMACMD5(PA_PluginParameters params) {

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_BLOB Param1;
    C_BLOB Param2;
    C_LONGINT Param3;
    C_TEXT returnValue;
    
    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    Param3.fromParamAtIndex(pParams, 3);
    
    CC_HMACHASH(16, EVP_md5, Param1, Param2, Param3, returnValue);
    
    returnValue.setReturn(pResult);
}

void HMACSHA1(PA_PluginParameters params) {

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_BLOB Param1;
    C_BLOB Param2;
    C_LONGINT Param3;
    C_TEXT returnValue;
    
    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    Param3.fromParamAtIndex(pParams, 3);
    
    CC_HMACHASH(20, EVP_sha1, Param1, Param2, Param3, returnValue);
    
    returnValue.setReturn(pResult);
}

void HMACSHA224(PA_PluginParameters params) {
    
    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_BLOB Param1;
    C_BLOB Param2;
    C_LONGINT Param3;
    C_TEXT returnValue;
    
    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    Param3.fromParamAtIndex(pParams, 3);
    
    CC_HMACHASH(28, EVP_sha224, Param1, Param2, Param3, returnValue);
    
    returnValue.setReturn(pResult);
}

void HMACSHA256(PA_PluginParameters params) {

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_BLOB Param1;
    C_BLOB Param2;
    C_LONGINT Param3;
    C_TEXT returnValue;
    
    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    Param3.fromParamAtIndex(pParams, 3);
    
    CC_HMACHASH(32, EVP_sha256, Param1, Param2, Param3, returnValue);
    
    returnValue.setReturn(pResult);
}

void HMACSHA384(PA_PluginParameters params) {

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_BLOB Param1;
    C_BLOB Param2;
    C_LONGINT Param3;
    C_TEXT returnValue;
    
    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    Param3.fromParamAtIndex(pParams, 3);
    
    CC_HMACHASH(48, EVP_sha384, Param1, Param2, Param3, returnValue);
    
    returnValue.setReturn(pResult);
}

void HMACSHA512(PA_PluginParameters params) {

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_BLOB Param1;
    C_BLOB Param2;
    C_LONGINT Param3;
    C_TEXT returnValue;
    
    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    Param3.fromParamAtIndex(pParams, 3);
    
    CC_HMACHASH(64, EVP_sha512, Param1, Param2, Param3, returnValue);
    
    returnValue.setReturn(pResult);
}

void HMACSHA512_224(PA_PluginParameters params) {
    
    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_BLOB Param1;
    C_BLOB Param2;
    C_LONGINT Param3;
    C_TEXT returnValue;
    
    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    Param3.fromParamAtIndex(pParams, 3);
    
    CC_HMACHASH(28, EVP_sha512_224, Param1, Param2, Param3, returnValue);
    
    returnValue.setReturn(pResult);
}

void HMACSHA512_256(PA_PluginParameters params) {

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_BLOB Param1;
    C_BLOB Param2;
    C_LONGINT Param3;
    C_TEXT returnValue;
    
    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    Param3.fromParamAtIndex(pParams, 3);
    
    CC_HMACHASH(32, EVP_sha512_256, Param1, Param2, Param3, returnValue);
    
    returnValue.setReturn(pResult);
}

void HMACSHA3_224(PA_PluginParameters params) {
    
    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_BLOB Param1;
    C_BLOB Param2;
    C_LONGINT Param3;
    C_TEXT returnValue;
    
    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    Param3.fromParamAtIndex(pParams, 3);
    
    CC_HMACHASH(28, EVP_sha3_224, Param1, Param2, Param3, returnValue);
    
    returnValue.setReturn(pResult);
}

void HMACSHA3_256(PA_PluginParameters params) {
    
    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_BLOB Param1;
    C_BLOB Param2;
    C_LONGINT Param3;
    C_TEXT returnValue;
    
    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    Param3.fromParamAtIndex(pParams, 3);
    
    CC_HMACHASH(32, EVP_sha3_256, Param1, Param2, Param3, returnValue);
    
    returnValue.setReturn(pResult);
}

void HMACSHA3_384(PA_PluginParameters params) {
   
    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_BLOB Param1;
    C_BLOB Param2;
    C_LONGINT Param3;
    C_TEXT returnValue;
    
    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    Param3.fromParamAtIndex(pParams, 3);
    
    CC_HMACHASH(48, EVP_sha3_384, Param1, Param2, Param3, returnValue);
    
    returnValue.setReturn(pResult);
}

void HMACSHA3_512(PA_PluginParameters params) {
    
    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_BLOB Param1;
    C_BLOB Param2;
    C_LONGINT Param3;
    C_TEXT returnValue;
    
    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    Param3.fromParamAtIndex(pParams, 3);
    
    CC_HMACHASH(64, EVP_sha3_512, Param1, Param2, Param3, returnValue);
    
    returnValue.setReturn(pResult);
}

/* HMAC does not support variable output length digests such as
 EVP_shake128() and EVP_shake256(). */

#pragma mark HASH

void CC_HASH(unsigned int hashlen, void (*CC)(const void *data, uint32_t len, unsigned char *md),
             C_BLOB &Param1,
             C_LONGINT &Param2,
             C_TEXT &returnValue) {
    
    uint8_t *buf = (uint8_t *)calloc(hashlen, sizeof(uint8_t));
    
    CC((unsigned char *)Param1.getBytesPtr(), Param1.getBytesLength(), buf);
    
    C_BLOB temp;
    temp.setBytes((const uint8_t *)buf, hashlen);
    switch (Param2.getIntValue())
    {
        case 1:
        temp.toB64Text(&returnValue);
        break;
        case 2:
        temp.toB64Text(&returnValue, true);
        break;
        default:
        temp.toHexText(&returnValue);
        break;
    }
    
    free(buf);
}

void MD5(PA_PluginParameters params) {

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_BLOB Param1;
    C_LONGINT Param2;
    C_TEXT returnValue;
    
    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    
    CC_HASH(16, CC_MD5, Param1, Param2, returnValue);
    
    returnValue.setReturn(pResult);
}

void SHA1(PA_PluginParameters params) {

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_BLOB Param1;
    C_LONGINT Param2;
    C_TEXT returnValue;
    
    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    
    CC_HASH(20, CC_SHA1, Param1, Param2, returnValue);
    
    returnValue.setReturn(pResult);
}

#pragma mark AES

void CC_AES(const EVP_CIPHER *cipher,
            C_BLOB &Param1,
            C_BLOB &Param2,
            C_LONGINT &Param3,
            C_LONGINT &Param5,
            C_LONGINT &Param6,
            C_BLOB &Param7,
            C_BLOB &Param8,
            C_TEXT &returnValue) {
    
    EVP_CIPHER_CTX *ctx = EVP_CIPHER_CTX_new();
    
    unsigned char key[EVP_MAX_KEY_LENGTH], iv[EVP_MAX_IV_LENGTH];
    
    const unsigned char *source = (const unsigned char *)Param1.getBytesPtr();
    int source_len = Param1.getBytesLength();
    int crypted_len, tail_len;
    
    bool key_and_iv_is_valid = false;
    
    if(  !Param2.getBytesLength()
       && Param7.getBytesLength()
       && Param8.getBytesLength()
       && Param7.getBytesLength() <= EVP_MAX_KEY_LENGTH
       && Param8.getBytesLength() <= EVP_MAX_IV_LENGTH)
    {
        memset(key, 0, EVP_MAX_KEY_LENGTH);
        memset( iv, 0, EVP_MAX_IV_LENGTH );
        memcpy(key, Param7.getBytesPtr(), Param7.getBytesLength());
        memcpy( iv, Param8.getBytesPtr(), Param8.getBytesLength());
        key_and_iv_is_valid = true;
    }else
    {
        // passphrase -> key, iv
        key_and_iv_is_valid = (EVP_BytesToKey(cipher, EVP_md5(), NULL,
                                              Param2.getBytesPtr(), Param2.getBytesLength(),
                                              2048, key, iv) > 0);
    }
    
    if (key_and_iv_is_valid) {
        if(EVP_CipherInit(ctx, cipher, key, iv, 0 == Param3.getIntValue()))
        {
            if(Param6.getIntValue())
            {
                EVP_CIPHER_CTX_set_padding(ctx, 0);
            }
            size_t buf_size = source_len + EVP_MAX_BLOCK_LENGTH;
            unsigned char *buf = (unsigned char *)calloc(buf_size, sizeof(unsigned char));
            if(EVP_CipherUpdate(ctx, buf, &crypted_len, source, source_len))
            {
                if(EVP_CipherFinal(ctx, (buf + crypted_len), &tail_len))
                {
                    crypted_len += tail_len;
                    C_BLOB temp;
                    temp.setBytes((const uint8_t *)buf, crypted_len);
                    
                    switch (Param5.getIntValue())
                    {
                        case 1:
                        temp.toB64Text(&returnValue);
                        break;
                        case 2:
                        temp.toB64Text(&returnValue, true);
                        break;
                        default:
                        temp.toHexText(&returnValue);
                        break;
                    }
                }
            }
            free(buf);
        }
        EVP_CIPHER_CTX_free(ctx);
    }
}

void AES128(PA_PluginParameters params) {
    
    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_BLOB Param1;
    C_BLOB Param2;
    C_LONGINT Param3;
    C_LONGINT Param4;
    C_LONGINT Param5;
    C_LONGINT Param6;
    C_BLOB Param7;
    C_BLOB Param8;
    C_TEXT returnValue;
    
    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    Param3.fromParamAtIndex(pParams, 3);
    Param4.fromParamAtIndex(pParams, 4);
    Param5.fromParamAtIndex(pParams, 5);
    Param6.fromParamAtIndex(pParams, 6);
    Param7.fromParamAtIndex(pParams, 7);
    Param8.fromParamAtIndex(pParams, 8);
    
    const EVP_CIPHER *cipher;
    
    switch (Param4.getIntValue())
    {
        case 0:
        cipher = EVP_aes_128_ecb();
        break;
        case 1:
        cipher = EVP_aes_128_cbc();
        break;
        case 2:
        cipher = EVP_aes_128_cfb1();
        break;
        case 3:
        cipher = EVP_aes_128_cfb8();
        break;
        case 4:
        cipher = EVP_aes_128_cfb128();
        break;
        case 5:
        cipher = EVP_aes_128_ofb();
        break;
        case 6:
        cipher = EVP_aes_128_ctr();
        break;
        case 7:
        cipher = EVP_aes_128_gcm();
        break;
        case 8:
        cipher = EVP_aes_128_ccm();
        break;
        case 9:
        cipher = EVP_aes_128_xts();
        break;
        default:
        cipher = EVP_aes_128_ecb();
        break;
    }
    
    CC_AES(cipher, Param1, Param2, Param3, Param5, Param6, Param7, Param8, returnValue);
    
    returnValue.setReturn(pResult);
}

void AES192(PA_PluginParameters params) {
    
    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_BLOB Param1;
    C_BLOB Param2;
    C_LONGINT Param3;
    C_LONGINT Param4;
    C_LONGINT Param5;
    C_LONGINT Param6;
    C_BLOB Param7;
    C_BLOB Param8;
    C_TEXT returnValue;
    
    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    Param3.fromParamAtIndex(pParams, 3);
    Param4.fromParamAtIndex(pParams, 4);
    Param5.fromParamAtIndex(pParams, 5);
    Param6.fromParamAtIndex(pParams, 6);
    Param7.fromParamAtIndex(pParams, 7);
    Param8.fromParamAtIndex(pParams, 8);
    
    const EVP_CIPHER *cipher;
    
    switch (Param4.getIntValue())
    {
        case 0:
        cipher = EVP_aes_192_ecb();
        break;
        case 1:
        cipher = EVP_aes_192_cbc();
        break;
        case 2:
        cipher = EVP_aes_192_cfb1();
        break;
        case 3:
        cipher = EVP_aes_192_cfb8();
        break;
        case 4:
        cipher = EVP_aes_192_cfb128();
        break;
        case 5:
        cipher = EVP_aes_192_ofb();
        break;
        case 6:
        cipher = EVP_aes_192_ctr();
        break;
        case 7:
        cipher = EVP_aes_192_gcm();
        break;
        case 8:
        cipher = EVP_aes_192_ccm();
        break;
        default:
        cipher = EVP_aes_192_ecb();
        break;
    }
    
    CC_AES(cipher, Param1, Param2, Param3, Param5, Param6, Param7, Param8, returnValue);
    
    returnValue.setReturn(pResult);
}

void AES256(PA_PluginParameters params) {
    
    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_BLOB Param1;
    C_BLOB Param2;
    C_LONGINT Param3;
    C_LONGINT Param4;
    C_LONGINT Param5;
    C_LONGINT Param6;
    C_BLOB Param7;
    C_BLOB Param8;
    C_TEXT returnValue;
    
    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    Param3.fromParamAtIndex(pParams, 3);
    Param4.fromParamAtIndex(pParams, 4);
    Param5.fromParamAtIndex(pParams, 5);
    Param6.fromParamAtIndex(pParams, 6);
    Param7.fromParamAtIndex(pParams, 7);
    Param8.fromParamAtIndex(pParams, 8);
    
    const EVP_CIPHER *cipher;
    
    switch (Param4.getIntValue())
    {
        case 0:
        cipher = EVP_aes_256_ecb();
        break;
        case 1:
        cipher = EVP_aes_256_cbc();
        break;
        case 2:
        cipher = EVP_aes_256_cfb1();
        break;
        case 3:
        cipher = EVP_aes_256_cfb8();
        break;
        case 4:
        cipher = EVP_aes_256_cfb128();
        break;
        case 5:
        cipher = EVP_aes_256_ofb();
        break;
        case 6:
        cipher = EVP_aes_256_ctr();
        break;
        case 7:
        cipher = EVP_aes_256_gcm();
        break;
        case 8:
        cipher = EVP_aes_256_ccm();
        break;
        case 9:
        cipher = EVP_aes_256_xts();
        break;
        default:
        cipher = EVP_aes_256_ecb();
        break;
    }
    
    CC_AES(cipher, Param1, Param2, Param3, Param5, Param6, Param7, Param8, returnValue);
    
    returnValue.setReturn(pResult);
}

#pragma mark RIPEMD

void RIPEMD160(PA_PluginParameters params) {

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_BLOB Param1;
    C_LONGINT Param2;
    C_TEXT returnValue;
    
    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    
    uint8_t *buf = (uint8_t *)calloc(20, sizeof(uint8_t));
    
    CC_RIPEMD160((unsigned char *)Param1.getBytesPtr(), Param1.getBytesLength(), buf);
    
    C_BLOB temp;
    temp.setBytes((const uint8_t *)buf, 20);
    
    switch (Param2.getIntValue())
    {
        case 1:
        temp.toB64Text(&returnValue);
        break;
        case 2:
        temp.toB64Text(&returnValue, true);
        break;
        default:
        temp.toHexText(&returnValue);
        break;
    }
    
    free(buf);
    
    returnValue.setReturn(pResult);
}

#pragma mark RSA

void CC_RSASHA(unsigned int hashlen, int nid, void (*CC)(const void *data, uint32_t len, unsigned char *md),
               C_BLOB &Param1,
               C_BLOB &Param2,
               C_LONGINT &Param3,
               C_TEXT &returnValue) {
    
    uint8_t *buf = (uint8_t *)calloc(hashlen, sizeof(uint8_t));
    unsigned int signatureLength = 0;
    
    CC((unsigned char *)Param1.getBytesPtr(), Param1.getBytesLength(), buf);
    BIO *bio = BIO_new_mem_buf((void *)Param2.getBytesPtr(), Param2.getBytesLength());
    
    if(bio)
    {
        RSA *key = NULL;
        key = PEM_read_bio_RSAPrivateKey(bio, NULL, NULL, NULL);
        if(key)
        {
            uint8_t *sgn = (uint8_t *)calloc(RSA_size(key), sizeof(uint8_t));
            if(RSA_sign(nid, buf, hashlen, sgn, &signatureLength, key))
            {
                C_BLOB temp;
                temp.setBytes((const uint8_t *)sgn, signatureLength);
                switch (Param3.getIntValue())
                {
                    case 1:
                    temp.toB64Text(&returnValue);
                    break;
                    case 2:
                    temp.toB64Text(&returnValue, true);
                    break;
                    default:
                    temp.toHexText(&returnValue);
                    break;
                }
            }
            free(sgn);
        }
        BIO_free(bio);
    }
    free(buf);
}

void RSASHA1(PA_PluginParameters params) {
    
    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_BLOB Param1;
    C_BLOB Param2;
    C_LONGINT Param3;
    C_TEXT returnValue;
    
    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    Param3.fromParamAtIndex(pParams, 3);
    
    CC_RSASHA(20, NID_sha1, CC_SHA1, Param1, Param2, Param3, returnValue);
    
    returnValue.setReturn(pResult);
}

void RSASHA256(PA_PluginParameters params) {
    
    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_BLOB Param1;
    C_BLOB Param2;
    C_LONGINT Param3;
    C_TEXT returnValue;
    
    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    Param3.fromParamAtIndex(pParams, 3);
    
    CC_RSASHA(32, NID_sha256, CC_SHA256, Param1, Param2, Param3, returnValue);
    
    returnValue.setReturn(pResult);
}

void CC_RSASHAVERIFY(unsigned int hashlen, int nid, void (*CC)(const void *data, uint32_t len, unsigned char *md),
                     C_BLOB &Param1,
                     C_BLOB &Param2,
                     C_TEXT &Param3,
                     C_LONGINT &Param4,
                     C_LONGINT &returnValue) {
    
    uint8_t *buf = (uint8_t *)calloc(hashlen, sizeof(uint8_t));
    
    CC((unsigned char *)Param1.getBytesPtr(), Param1.getBytesLength(), buf);
    BIO *bio = BIO_new_mem_buf((void *)Param2.getBytesPtr(), Param2.getBytesLength());
    
    if(bio)
    {
        RSA *key = NULL;
        key = PEM_read_bio_RSA_PUBKEY(bio, NULL, NULL, NULL);
        if(key)
        {
            C_BLOB temp;
            
            switch (Param4.getIntValue())
            {
                case 1:
                temp.fromB64Text(&Param3);
                break;
                default:
                temp.fromHexText(&Param3);
                break;
            }
            
            if(RSA_verify(nid, buf, hashlen, (unsigned char *)temp.getBytesPtr(), temp.getBytesLength(), key))
            {
                returnValue.setIntValue(1);
            }
            
        }
        BIO_free(bio);
    }
    free(buf);
}

void RSAVERIFYSHA1(PA_PluginParameters params) {

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_BLOB Param1;
    C_BLOB Param2;
    C_TEXT Param3;
    C_LONGINT Param4;
    C_LONGINT returnValue;
    
    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    Param3.fromParamAtIndex(pParams, 3);
    Param4.fromParamAtIndex(pParams, 4);
    
    CC_RSASHAVERIFY(20, NID_sha1, CC_SHA1, Param1, Param2, Param3, Param4, returnValue);
    
    returnValue.setReturn(pResult);
}

void RSAVERIFYSHA256(PA_PluginParameters params) {

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_BLOB Param1;
    C_BLOB Param2;
    C_TEXT Param3;
    C_LONGINT Param4;
    C_LONGINT returnValue;
    
    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    Param3.fromParamAtIndex(pParams, 3);
    Param4.fromParamAtIndex(pParams, 4);
    
    CC_RSASHAVERIFY(32, NID_sha256, CC_SHA256, Param1, Param2, Param3, Param4, returnValue);
    
    returnValue.setReturn(pResult);
}

#pragma mark SHA-2

void SHA224(PA_PluginParameters params) {
    
    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_BLOB Param1;
    C_LONGINT Param2;
    C_TEXT returnValue;
    
    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    
    CC_HASH(28, CC_SHA224, Param1, Param2, returnValue);
    
    returnValue.setReturn(pResult);
}

void SHA256(PA_PluginParameters params) {
    
    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_BLOB Param1;
    C_LONGINT Param2;
    C_TEXT returnValue;
    
    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    
    CC_HASH(32, CC_SHA256, Param1, Param2, returnValue);
    
    returnValue.setReturn(pResult);
}

void SHA384(PA_PluginParameters params) {
    
    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_BLOB Param1;
    C_LONGINT Param2;
    C_TEXT returnValue;
    
    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    
    CC_HASH(48, CC_SHA384, Param1, Param2, returnValue);
    
    returnValue.setReturn(pResult);
}

void SHA512(PA_PluginParameters params) {
    
    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_BLOB Param1;
    C_LONGINT Param2;
    C_TEXT returnValue;
    
    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    
    CC_HASH(64, CC_SHA512, Param1, Param2, returnValue);
    
    returnValue.setReturn(pResult);
}

void SHA512_224(PA_PluginParameters params) {
    
    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_BLOB Param1;
    C_LONGINT Param2;
    C_TEXT returnValue;
    
    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    
    CC_HASH(28, CC_SHA512_224, Param1, Param2, returnValue);
    
    returnValue.setReturn(pResult);
}

void SHA512_256(PA_PluginParameters params) {
    
    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_BLOB Param1;
    C_LONGINT Param2;
    C_TEXT returnValue;
    
    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    
    CC_HASH(32, CC_SHA512_256, Param1, Param2, returnValue);
    
    returnValue.setReturn(pResult);
}

#pragma mark SHA-3

void SHA3_224(PA_PluginParameters params) {

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_BLOB Param1;
    C_LONGINT Param2;
    C_TEXT returnValue;
    
    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    
    CC_HASH(28, CC_SHA3_224, Param1, Param2, returnValue);
    
    returnValue.setReturn(pResult);
}

void SHA3_256(PA_PluginParameters params) {

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_BLOB Param1;
    C_LONGINT Param2;
    C_TEXT returnValue;
    
    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    
    CC_HASH(32, CC_SHA3_256, Param1, Param2, returnValue);
    
    returnValue.setReturn(pResult);
}

void SHA3_384(PA_PluginParameters params) {

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_BLOB Param1;
    C_LONGINT Param2;
    C_TEXT returnValue;
    
    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    
    CC_HASH(48, CC_SHA3_384, Param1, Param2, returnValue);
    
    returnValue.setReturn(pResult);
}

void SHA3_512(PA_PluginParameters params) {

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_BLOB Param1;
    C_LONGINT Param2;
    C_TEXT returnValue;
    
    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    
    CC_HASH(64, CC_SHA3_512, Param1, Param2, returnValue);
    
    returnValue.setReturn(pResult);
}

void SHAKE128(PA_PluginParameters params) {
    
    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_BLOB Param1;
    C_LONGINT Param2;
    C_TEXT returnValue;
    
    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    
    CC_HASH(32, CC_SHAKE128, Param1, Param2, returnValue);
    
    returnValue.setReturn(pResult);
}

void SHAKE256(PA_PluginParameters params) {
    
    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_BLOB Param1;
    C_LONGINT Param2;
    C_TEXT returnValue;
    
    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    
    CC_HASH(64, CC_SHAKE256, Param1, Param2, returnValue);
    
    returnValue.setReturn(pResult);
}
